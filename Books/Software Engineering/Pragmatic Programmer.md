# The Pragmatic Programmer

## Table Of Contents

1. [[#Quick Reads]]
	1. [[#Tips]]
	2. [[#Quotes]]
2. [[#Preface]]
3. [[#A Pragmatic Programmer]]
	1. [[#The Cat Ate My Source Code]]
	2. [[#Software Entropy]]
	3. [[#Stone Soup and Boiled Frogs]]
	4. [[#Good Enough Software]]
	5. [[#Your Knowledge Portfolio]]

## Quick Reads

### Tips

1. _Care About Your Craft_
2. _Think! About Your Work_
3. _Provide Options, Don’t Make Lame Excuses_
4. _Don’t Live with Broken Windows_
5. _Be a Catalyst for Change_
6. _Remember the Big Picture_
7. _Make Quality a Requirements Issue_

### Quotes

Preface -
* _We who cut mere stones must always be envisioning cathedrals
-Quarry worker's creed_
* _"Kaizen" - A Japanese term concept of continuously making many small improvements_
* _“When I use a word,” Humpty Dumpty said, in rather a scornful tone, “it means just what I choose it to mean-neither more nor less.”
-Lewis Carroll, Through the Looking-Glass_

A Pragmatic Programmer
* _The greatest of all weaknesses is the fear of appearing weak.
-J. B. Bossuet, Politics from Holy Writ, 1709_

## Preface

What makes a Pragmatic Programmer
* Early Adopter/fast adapter
* Inquisitive
* Critical Thinker
* Realistic
* Jack of all trades

## A Pragmatic Programmer

### The Cat Ate My Source Code

Take Responsibility. Don't make excuses. Find solution or list the options and try to get help in figuring out the best option.

Try to flush out the lame excuses before voicing them aloud. If you must, tell your cat first. After all, if little Tiddles is going to take the blame. . . .

_Challenge_: How do you react when someone-such as a bank teller, an auto mechanic, or a clerk-comes to you with a lame excuse? What do you think of them and their company as a result?
_Answer_: I think that they may be incompetent in that topic or not willing to put the effort. The company image is also tarnished as a result.

### Software Entropy

Software is generally immune to physical laws except _entropy_.
Many factors can contribute to rotting like -
* Psyphology or culture at work

Don’t leave _broken windows_ (bad designs, wrong decisions, or poor
code) unrepaired. 
* Fix each one as soon as it is discovered. 
* If there is insufficient time to fix it properly, then _board it up_.
Perhaps you can comment out the offending code, or display a "Not Implemented" message, or substitute dummy data instead. Take some action to prevent further damage and to show that you’re on top of the situation.

If you find yourself working on a project with quite a few broken windows, it’s all too easy to slip into the mindset of “_All the rest of this code is crap, I’ll just follow suit_.”

_Challenge_: Help strengthen your team by surveying your computing “neighborhood.” Choose two or three “broken windows” and discuss with your colleagues what the problems are and what could be done to fix them.
_Answer_: 

_Challenge_: Can you tell when a window first gets broken? What is your reaction? If it was the result of someone else’s decision, or a management edict, what can you do about it?
_Answer_: It is very difficult to determine when a window is broken first.
For an existing broken window, search for the tape that is holding it. Try to heal it. If that is not possible, talking with team to understand the situation and to mitigate the affect.

### Stone Soup and Boiled Frogs

Every now and then, you might want to emulate the soldiers.

You may be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes—you know it’s right. But ask permission to tackle the whole thing and you’ll be met with delays and blank stares. People will form committees, budgets will need approval, and things will get complicated. Everyone will guard their own resources. Sometimes this is called “start-up fatigue.”

It’s time to bring out the stones. Work out what you can reasonably ask for. Develop it well. Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added .” Pretend it’s not important. Sit back and wait for them to start asking you to add the functionality you originally wanted. People find it easier to join an ongoing success. Show them a glimpse of the future and you’ll get them to rally around.

Keep an eye on the big picture. Constantly review
what’s happening around you, not just what you personally are doing.

_Challenges_: While reviewing a draft of this book, John Lakos raised the following issue:
The soldiers progressively deceive the villagers, but the change they catalyze does them all good. However, by progressively deceiving the frog, you’re doing it harm. Can you determine whether you’re making stone soup or frog soup when you try to catalyze change? Is the decision subjective or objective?
_Answer_: If the decision is founded in facts, there is a possibility to have an objective decision. Often times, it can be driven by ego or other psyhological factors making it subjective.

### Good Enough Software

Ed Yourdon described in IEEE Software \[You95\], displine yourself to write software that is good enough
* good enough for your users
* good enough for future maintainers
* for your peace of mind

Great software today is often preferable to perfect software tomorrow

Know When to Stop - like painting on a canvas, software will be re-written every few years ... so know when to stop ...
with too many layers, the painting is lost in the painting ...

_Challenge_: Look at the manufacturers of the software tools and operating systems that you use. Can you find evidence that these companies are comfortable shipping software they know is not perfect? As a user, would you rather 
(1) wait for them to get all the bugs out
(2) have a complex software and accept some bugs
(3) opt for simpler software with fewer bugs
_Answer_: It would depend on the situation.
I would choose option
(1) for my cars software
(2) for softwares that are not affecting my work
(3) for software that I use for work

_Challenge_: Consider the effect of modularization on the delivery of software. Will it take more or less time to get a monolithic block of software to the required quality compared with a system designed in modules? Can you find commercial examples?
_Answer_: Modular system design takes less time in comparison to monolithic software development. It allows for parallel development of modules that need to be integrated later.  

### Your Knowledge Portfolio

### Communicate

## A Pragmatic Approach

### The Evils of Duplication

### Orthogonality

### Reversibility

### Tracer Bullets

### Prototypes and Post###it Notes

### Domain Languages

### Estimating

## The Basic Tools

### The Power of Plain Text

### Shell Games

### Power Editing

### Source Code Control

### Debugging

### Text manipulation

### Code Generators

## Pragmatic Paranoia

### Design by Contract

### Dead Programs Tell No Lies

### Assertive Programming

### When to Use Exceptions

### How to Balance Resources

## 5 Bend or Break

### Decoupling and the Law of Demeter

### Metaprogramming

### Temporal Coupling

### It's Just a View

### Blackboards

## 6 While You Are Coding

### Programming by Coincidence

### Algorithm Speed

### Refactoring

### Code That's Easy to Test

### Evil Wizards

## 7 Before the Project

### The Requirements Pit

### Solving Impossible Puzzles

### Not Until You're Ready

### The Specification Trap

### Circles and Arrows

## 8 Pragmatic Projects

### Pragmatic Teams

### Ubiquitous Automation

### Ruthless Testing

### It's All Writing

### Great Expectations

### Pride and Prejudice

# Hashtags

#softwareengineering